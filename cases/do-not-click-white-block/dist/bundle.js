/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// var lg = log4web.newLogger();\n// var ui = window['log4web-ui-mobile'];\n// lg.config({\n//   level: log4web.LogLevel.TRACE,\n//   // level: log4web.LogLevel.ERROR,\n//   defaultStore: {\n//     enable: true,\n//   },\n//   defaultFanner: {\n//     enable: false\n//   },\n//   'log4web-ui-mobile': {}\n// })\n// lg.use(ui.Core); //使用默认的输出插件(console/alert)\n// lg.setSpinBackColor('red');\n// lg.showFloatSpin();\nvar resources = {\n  start: undefined,\n  score: undefined\n};\n\nfunction loadImg(url, cb) {\n  var img = new Image(); // 创建img元素\n\n  img.onload = function () {\n    // 执行drawImage语句\n    cb && cb();\n  };\n\n  img.crossOrigin = \"Anonymous\";\n  img.src = url; // 设置图片源地址\n\n  return img;\n} //这里也可以修改成整体项目使用的资源加载器来实现预加载。这里简单写一下\n\n\nfunction loadRes(cb) {\n  resources.score = loadImg('https://wbpmrck.github.io/animation-study/cases/do-not-click-white-block/img/score-bg.png', function () {\n    resources.start = loadImg('https://wbpmrck.github.io/animation-study/cases/do-not-click-white-block/img/start.png', function () {\n      cb && cb();\n    });\n  });\n}\n\nvar _requestAnimationFrame = window.requestAnimationFrame;\nvar config = {\n  // clock: 1000, // 控制动画帧率。如果是undefined,默认requestAnimationFrame，否则使用计时器(duration=clock)\n  canvas: {\n    width: 0,\n    height: 0,\n    useDpr: 1 //当前画布使用的dpr (只有使用高清模式会改变)\n\n  },\n  getLevelConfig: function getLevelConfig(line) {\n    var levelConfig = config.level.filter(function (l) {\n      return line >= (l.from == undefined ? 0 : l.from) && line <= (l.to == undefined ? Infinity : l.to);\n    })[0];\n    return levelConfig;\n  },\n  addGradients: false,\n  //此开关控制是否在画面上绘制渐变的装饰性圆点\n  //如果开关打开，下面配置的渐变圆点会绘制\n  gradients: [{\n    x0: 310,\n    y0: 160,\n    r0: 10,\n    x1: 310,\n    y1: 160,\n    r1: 0,\n    shadowBlur: 40\n  }, {\n    x0: 210,\n    y0: 180,\n    r0: 30,\n    x1: 210,\n    y1: 180,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 230,\n    y0: 270,\n    r0: 25,\n    x1: 230,\n    y1: 270,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 45,\n    y0: 370,\n    r0: 110,\n    x1: 45,\n    y1: 370,\n    r1: 0,\n    shadowBlur: 90\n  }, {\n    x0: 330,\n    y0: 360,\n    r0: 20,\n    x1: 330,\n    y1: 360,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 320,\n    y0: 380,\n    r0: 16,\n    x1: 320,\n    y1: 380,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 100,\n    y0: 420,\n    r0: 26,\n    x1: 100,\n    y1: 420,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 250,\n    y0: 450,\n    r0: 46,\n    x1: 250,\n    y1: 450,\n    r1: 0,\n    shadowBlur: 10\n  }, {\n    x0: 270,\n    y0: 430,\n    r0: 18,\n    x1: 270,\n    y1: 430,\n    r1: 0,\n    shadowBlur: 10\n  }],\n  lines: 5,\n  //全屏幕高度可以完整渲染多少行格子\n  lineHeight: undefined,\n  //一行高度\n  level: [{\n    from: 0,\n    to: 1,\n    block: 4,\n    // 备选块数\n    target: 1,\n    //需要点击的块数\n    speed: 550 //多少时间滚动完一行 \n\n  }, {\n    from: 2,\n    to: 5,\n    block: 4,\n    target: 1,\n    speed: 500\n  }, {\n    from: 6,\n    to: 15,\n    block: 4,\n    target: 2,\n    speed: 450\n  }, {\n    from: 16,\n    to: 30,\n    block: 4,\n    target: 2,\n    speed: 400\n  }, {\n    from: 31,\n    to: 50,\n    block: 4,\n    target: 2,\n    speed: 360\n  }, {\n    from: 51,\n    to: 80,\n    block: 4,\n    target: 2,\n    speed: 320\n  }, {\n    from: 81,\n    to: 200,\n    block: 4,\n    target: 3,\n    speed: 300\n  }, {\n    from: 201,\n    to: 300,\n    block: 4,\n    target: 3,\n    speed: 280\n  }, {\n    from: 301,\n    block: 4,\n    target: 3,\n    speed: 250\n  }]\n};\n\nif (config.clock) {\n  // lg.trace(\"设置了时钟:\" + config.clock);\n  _requestAnimationFrame = function _requestAnimationFrame(fn) {\n    setTimeout(fn, config.clock);\n  };\n}\n\nvar STATE = {\n  PAUSED: 1,\n  ING: 2,\n  END: 3\n};\nvar data = {\n  state: STATE.PAUSED,\n  //当前状态\n  score: 0,\n  //分数\n  lastTick: undefined,\n  // 上次帧发生时刻\n  blocksInView: [],\n  // 所有仍在屏幕中的块信息\n  lineCount: 0,\n  // 已经生成的行数\n  walkBlock: function walkBlock(handler) {\n    this.blocksInView.forEach(function (line) {\n      line.forEach(function (blk) {\n        handler && handler(blk);\n      });\n    });\n  }\n};\n\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min; //不含最大值，含最小值\n}\n\nfunction getRandomIntN(min, max, count) {\n  if (count === 1) {\n    return [getRandomInt(min, max)];\n  } else if (count > 1) {\n    var result = [];\n    var indexs = []; //索引数组\n\n    for (var i = min; i < max; i++) {\n      indexs.push(i);\n    }\n\n    while (result.length < count) {\n      var next = getRandomInt(0, indexs.length);\n      result.push(indexs[next]);\n    }\n\n    return result;\n  } else {\n    return [];\n  }\n}\n\nvar canvasObject = document.getElementById('root'); // var ctx = canvasObject.getContext('2d');\n\nvar ctx = canvasObject.getContext('2d', {\n  alpha: false\n});\n/**\n * 定义一个矩形块。这个对象只用于在内存中表示游戏数据\n * @param {*} x \n * @param {*} y \n * @param {*} w \n * @param {*} h \n * @param {Boolean} isBlack \n * @param {Number} lineNum \n */\n\nfunction Block(x, y, w, h, isBlack, lineNum) {\n  this.lineNum = lineNum;\n  this.x = x;\n  this.y = y;\n  this.w = w;\n  this.h = h;\n  this.isBlack = isBlack;\n  this.knocked = false; //是否在游戏中已经被敲中\n}\n/**\n * 方块当前是否包含点击的触点\n */\n\n\nBlock.prototype.containPoint = function (x, y) {\n  if (this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y) {\n    return true;\n  } else {\n    return false;\n  }\n};\n/**\n * 尝试点击方块，返回是否处理标记\n */\n\n\nBlock.prototype.tryKnock = function (x, y) {\n  // console.log(`knock:[${x},${y},this:[${this.x},${this.y},${this.w},${this.h}]`)\n  var contain = this.containPoint(x, y);\n\n  if (contain) {\n    this.knocked = true; //只有黑色可点\n\n    if (!this.isBlack) {\n      //如果点了白色，直接结束\n      end();\n      return undefined;\n    } else {\n      data.score++; //第一行的方块被点击的时候，可以直接开始\n\n      if (this.lineNum === 0 && data.state !== STATE.ING) {\n        start();\n      }\n    }\n  }\n\n  return contain;\n};\n/**\n * 根据自身属性产生渐变样式\n */\n\n\nBlock.prototype.getFillStyle = function (ctx) {\n  var blk = this;\n  var gradient; //如果是黑块\n\n  if (blk.isBlack) {\n    //黑块的渐变需要以自身位置为中心\n    gradient = ctx.createLinearGradient(blk.w / 2, blk.y, blk.w / 2, blk.y + blk.h); //点中和没点中的不一样\n\n    if (blk.knocked) {\n      gradient.addColorStop(0, \"#7071D2\");\n      gradient.addColorStop(1, \"#8363BE\");\n      ctx.fillStyle = gradient;\n    } else {\n      gradient.addColorStop(0, \"#0D3E5C\");\n      gradient.addColorStop(1, \"#050C17\");\n      ctx.fillStyle = gradient;\n    }\n  } else {\n    //白块的渐变以整个canvas为中心\n    gradient = ctx.createLinearGradient(0, 0, 0, config.canvas.height); //白块 点中和没点中的不一样\n\n    if (blk.knocked) {\n      ctx.fillStyle = '#FF4136'; // ctx.fillStyle = gradient;\n    } else {\n      gradient.addColorStop(0, \"#6E85F9\");\n      gradient.addColorStop(1, \"#AB76E4\");\n      ctx.fillStyle = gradient;\n    }\n  }\n};\n\nBlock.prototype.getFillStyleOld = function (ctx) {\n  var blk = this; //如果是黑块\n\n  if (blk.isBlack) {\n    //点中和没点中的不一样\n    if (blk.knocked) {\n      ctx.fillStyle = '#AAA';\n    } else {\n      ctx.fillStyle = '#000';\n    }\n  } else {\n    //白块 点中和没点中的不一样\n    if (blk.knocked) {\n      ctx.fillStyle = '#FF4136';\n    } else {\n      ctx.fillStyle = '#fff';\n    }\n  }\n};\n\nBlock.prototype.moveDown = function (y) {\n  // lg.trace('movedown=' + y)\n  // TODO:这里需要修改，Y不一定要增加，如果高度没达到设定高度，应该增加高度。另外需要看下逻辑，高度是不是可以正常到0\n  this.y += y; // //检测是否超出底部，是的话修改自身的高度 if (this.y + this.h > config.canvas.height) {   this.h\n  // = config.canvas.height - this.y }\n};\n\nBlock.prototype.visibleRect = function () {\n  var r = {\n    x: this.x,\n    y: this.y,\n    w: this.w,\n    h: this.h\n  }; //如果完全不可见，则完全不需要绘制\n\n  if (this.y <= 0 - config.lineHeight || this.y >= config.canvas.height) {\n    return undefined;\n  } else {\n    if (this.y < 0) {\n      r.y = 0;\n      r.h = this.h + this.y;\n    } else {\n      r.h = Math.min(config.canvas.height - this.y, this.h);\n    }\n\n    return r;\n  }\n};\n/**\n * 获取指定canvas位置的像素颜色\n * @param {*} ctx \n * @param {*} x \n * @param {*} y \n */\n\n\nfunction getPosColor(ctx, x, y) {\n  var pixel = ctx.getImageData(x, y, 1, 1);\n  var data = pixel.data;\n  var rgba = 'rgba(' + data[0] + ',' + data[1] + ',' + data[2] + ',' + data[3] / 255 + ')';\n  return rgba;\n}\n/**\n * 部分HDPI(DPR>1)的机器上，canvas绘制图片会模糊，因为DPR的原因，这个函数可以把画布的绘制大小放大，展示的时候通过style缩放回去\n * @param {HTMLCanvasElement} canvas \n */\n\n\nfunction setupHDPICanvas(canvas) {\n  // Get the device pixel ratio, falling back to 1.\n  var dpr = window.devicePixelRatio || 1; // Get the size of the canvas in CSS pixels.\n\n  var rect = canvas.getBoundingClientRect(); // Give the canvas pixel dimensions of their CSS\n  // size * the device pixel ratio.\n\n  canvas.width = rect.width * dpr;\n  canvas.height = rect.height * dpr; //修改配置\n\n  config.canvas.useDpr = dpr;\n  config.canvas.width = canvas.width;\n  config.canvas.height = canvas.height;\n  canvas.style.width = rect.width + \"px\";\n  canvas.style.height = rect.height + \"px\";\n} //初始化画布，初始block\n\n\nfunction init() {\n  var docEleRect = window.document.documentElement.getBoundingClientRect();\n  config.canvas.width = docEleRect.width;\n  config.canvas.height = docEleRect.height;\n  canvasObject.setAttribute('width', config.canvas.width);\n  canvasObject.setAttribute('height', config.canvas.height); //将画布设置为高清模式\n\n  setupHDPICanvas(canvasObject);\n  canvasObject.addEventListener('touchstart', handleClick, false);\n  config.lineHeight = Math.floor(config.canvas.height / config.lines);\n  onUpdate(data, 0); //帧数0. update函数初始化整个块区域，但是不进行移动\n\n  onPaint(ctx, data); //绘制出初始状态\n}\n\nfunction start() {\n  // lg.trace('start');\n  data.state = STATE.ING;\n\n  _requestAnimationFrame(onFrame);\n}\n\nfunction handleClick(e) {\n  // console.log(e);\n  if (data.state !== STATE.END) {\n    var _e$touches$ = e.touches[0],\n        clientX = _e$touches$.clientX,\n        clientY = _e$touches$.clientY;\n    clientX = config.canvas.useDpr * clientX;\n    clientY = config.canvas.useDpr * clientY;\n    data.walkBlock(function (blk) {\n      blk.tryKnock(clientX, clientY);\n    });\n  }\n}\n\nfunction pause() {\n  data.state = STATE.PAUSED;\n}\n\nfunction resume() {\n  data.state = STATE.ING;\n}\n\nfunction end() {\n  data.state = STATE.END;\n  setTimeout(function () {\n    alert(\"\\u6E38\\u620F\\u7ED3\\u675F\\uFF0C\\u5F97\\u5206:\".concat(data.score));\n  }, 22);\n}\n/**\n * 处理一帧\n */\n\n\nfunction onFrame(timestamp) {\n  // lg.trace('onFrame');\n  onUpdate(data, 1);\n  onPaint(ctx, data);\n\n  if (data.state === STATE.ING) {\n    _requestAnimationFrame(onFrame);\n  }\n}\n/**\n * 更新游戏状态对象\n * @param {Object} state\n */\n\n\nfunction onUpdate(state, ticks) {\n  // 负责新增一行需要绘制的方块元数据\n  function _appendLine(preTop) {\n    // 获取当前生成行的难度配置 let levelConfig = config   .level   .filter((l) => {     return\n    // (state.lineCount >= (l.from == undefined       ? 0       : l.from)) &&\n    // (state.lineCount <= (l.to == undefined       ? Infinity       : l.to)) })[0];\n    var levelConfig = config.getLevelConfig(state.lineCount); //按照当前行的绘制数量、决定每一个块的宽度\n\n    var blockWidth = Math.floor(config.canvas.width / levelConfig.block);\n    var startX = 0;\n    var startY = preTop - config.lineHeight;\n    var line = [];\n    var blackIds = getRandomIntN(0, levelConfig.block, levelConfig.target); // console.log('blackIds:') console.log(blackIds)\n\n    var _loop = function _loop(i) {\n      var isBlack = blackIds.filter(function (id) {\n        return id == i;\n      }).length > 0; // console.log(`i:${i}.isBlack:${isBlack}`)\n\n      var blk = new Block(startX, startY, blockWidth, config.lineHeight, isBlack, state.lineCount);\n      line.push(blk);\n      startX += blockWidth;\n    };\n\n    for (var i = 0; i < levelConfig.block; i++) {\n      _loop(i);\n    }\n\n    state.lineCount++;\n    return line;\n  }\n\n  function _checkBottomLineAndRemove(bottomLine) {\n    //如果最后一行即将超出可视范围\n    if (bottomLine[0].y >= config.canvas.height) {\n      // 先检查该行的黑块是否全部正常消除\n      var exits = bottomLine.filter(function (blk) {\n        return blk.isBlack && !blk.knocked;\n      }).length;\n\n      if (exits) {\n        end();\n      } else {\n        data.blocksInView.splice(0, 1);\n\n        _appendLine(0); //新增一行，这时候最上面一行一定是顶在顶部的，所以直接传0\n\n      }\n    }\n  } //初始化的时候，需要保证内存里有比显示需要多1行\n\n\n  var needLines = config.lines + 1;\n\n  while (data.blocksInView.length < needLines) {\n    var preTop = config.canvas.height;\n\n    if (data.blocksInView.length > 0) {\n      preTop = data.blocksInView[data.blocksInView.length - 1][0].y;\n    }\n\n    var newLine = _appendLine(preTop);\n\n    data.blocksInView.push(newLine);\n  }\n\n  bottomLine = data.blocksInView[0]; //获取当前最下面一行\n\n  var levelConfig = config.getLevelConfig(bottomLine[0].lineNum); //每一个tick,都将所有方块向下移动\n\n  for (var m = 0; m < ticks; m++) {\n    data.blocksInView.forEach(function (l) {\n      l.forEach(function (b) {\n        // b.moveDown(Math.floor(levelConfig.speed / 1000 * 16)); //一帧认为是16ms\n        // lg.trace('移动block');\n        b.moveDown(Math.max(Math.floor(config.lineHeight / levelConfig.speed * 16), 1)); //一帧认为是16ms\n      });\n    }); //移动完毕之后，看看是否有行需要移除的。有的话，移除该行，新增一行\n\n    _checkBottomLineAndRemove(bottomLine); // if (bottomLine[0].y >= config.canvas.height) {   data     .blocksInView\n    // .splice(0, 1);   _appendLine(0); //新增一行，这时候最上面一行一定是顶在顶部的，所以直接传0 }\n\n  }\n}\n/**\n * 负责根据当前游戏状态，绘制整个游戏区域\n * @param {Canvas} ctx\n * @param {Object} state\n */\n\n\nfunction onPaint(ctx, state) {\n  // lg.trace('config.canvas.width=' + config.canvas.width);\n  // lg.trace('config.canvas.height=' + config.canvas.height);\n  ctx.clearRect(0, 0, config.canvas.width, config.canvas.height); // clear canvas\n  // 遍历整个可视区域的block二维数组，从下向上进行绘制。需要判断如果超出可视范围之前，则只需要画可视范围内的部分\n\n  state.blocksInView.forEach(function (line) {\n    line.forEach(function (blk) {\n      // console.log(blk);\n      var r = blk.visibleRect(); // console.log(r);\n\n      if (r) {\n        blk.getFillStyle(ctx);\n        ctx.fillRect(r.x, r.y, r.w, r.h); //如果这个块是黑色且在第一行，则画开始按钮\n\n        if (blk.isBlack && blk.lineNum == 0 && !blk.knocked) {\n          ctx.drawImage(resources.start, r.x + (r.w - 55 * config.canvas.useDpr) / 2, r.y + (r.h - 27 * config.canvas.useDpr) / 2, 55 * config.canvas.useDpr, 27 * config.canvas.useDpr);\n        }\n      }\n    });\n  }); //画点缀的渐变圆\n\n  if (config.addGradients) {\n    config.gradients.forEach(function (circle) {\n      var gradient = ctx.createRadialGradient(circle.x0 * config.canvas.useDpr, circle.y0 * config.canvas.useDpr, circle.r0 * config.canvas.useDpr, circle.x1 * config.canvas.useDpr, circle.y1 * config.canvas.useDpr, circle.r1 * config.canvas.useDpr);\n      var targetColor = getPosColor(ctx, circle.x0 * config.canvas.useDpr, circle.y0 * config.canvas.useDpr);\n      gradient.addColorStop(0, targetColor);\n      gradient.addColorStop(1, \"#efe\");\n      ctx.fillStyle = gradient;\n      ctx.shadowColor = circle.shadowBlur * config.canvas.useDpr;\n      ctx.shadowBlur = 10;\n      ctx.beginPath();\n      ctx.arc(circle.x0 * config.canvas.useDpr, circle.y0 * config.canvas.useDpr, circle.r0 * config.canvas.useDpr, 0, 2 * Math.PI);\n      ctx.fill(); // ctx.fillRect((circle.x0 - circle.r0) * config.canvas.useDpr, (circle.y0 - circle.r0) * config.canvas.useDpr, circle.r0 * 2 * config.canvas.useDpr, circle.r0 * 2 * config.canvas.useDpr);\n    });\n  } //画纵向分割线\n\n\n  ctx.beginPath();\n  ctx.strokeStyle = '#FFFFFD';\n  ctx.lineWidth = 1 * config.canvas.useDpr;\n  ctx.moveTo(config.canvas.width / 4, 0);\n  ctx.lineTo(config.canvas.width / 4, config.canvas.height);\n  ctx.moveTo(config.canvas.width / 2, 0);\n  ctx.lineTo(config.canvas.width / 2, config.canvas.height);\n  ctx.moveTo(config.canvas.width / 4 * 3, 0);\n  ctx.lineTo(config.canvas.width / 4 * 3, config.canvas.height);\n  ctx.stroke(); //画分数-背景\n  // var scoreGradient = ctx.createLinearGradient(config.canvas.width / 4, 0, config.canvas.width / 4 * 3, 0);\n  // scoreGradient.addColorStop(0, '#6E85F9');\n  // scoreGradient.addColorStop(0.5, '#301B72');\n  // scoreGradient.addColorStop(1, '#6E85F9');\n  // ctx.fillStyle = scoreGradient;\n  // ctx.fillRect(config.canvas.width / 4, 10, config.canvas.width / 2, 36);\n\n  ctx.drawImage(resources.score, config.canvas.width / 4, 10 * config.canvas.useDpr, config.canvas.width / 2, 33 * config.canvas.useDpr); //画分数-分数\n\n  ctx.fillStyle = \"#FAD35F\";\n  ctx.font = \"bold \".concat(22 * config.canvas.useDpr, \"px serif\");\n  ctx.textAlign = \"center\"; // ctx.fillText(data.score, config.canvas.width / 2, (10 + 33 / 2) * config.canvas.useDpr);\n\n  ctx.fillText(data.score, config.canvas.width / 2, (10 + 33 - (33 - 22) / 2) * config.canvas.useDpr - 5);\n} //开始初始化\n\n\nloadRes(function () {\n  init();\n}); // start();\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

/******/ });